import { Command } from "commander";
import { promises as fs, existsSync } from "fs";
import * as path from "path";
import * as os from "os";
import { fetchManagementApi } from "../../utils/index.js";
import ts from "typescript";
import { compile } from "json-schema-to-typescript";
import chalk from "chalk";

export const modalitiesCheckCommand = new Command("check")
  .description("Type check local TypeScript definitions against server schemas")
  .argument(
    "[file]",
    "TypeScript file to check (e.g. one generated by 'modalities generate')",
    "modalities-types.d.ts",
  )
  .action(async (file: string) => {
    // Fetch server models
    const data: any = await fetchManagementApi(`models`);
    const serverModels: Record<string, any> = {};
    for (const item of data.items) {
      serverModels[item.modelId] = item.schema;
    }

    // Read local TypeScript file
    const filePath = path.resolve(process.cwd(), file);
    if (!existsSync(filePath)) {
      console.error(`File not found: ${filePath}`);
      process.exit(1);
    }
    const tsSource = await fs.readFile(filePath, "utf8");

    // Generate remote types from schemas
    let remoteTypesSource = "";
    for (const modelId in serverModels) {
      const typeName = modelId.replace(/[^a-zA-Z0-9_]/g, "");
      const tsType = await compile(serverModels[modelId], typeName, {
        bannerComment: "",
        additionalProperties: false,
      });
      remoteTypesSource += tsType + "\n";
    }

    // Create a virtual TypeScript program with both local and remote types
    const tmpRemotePath = path.join(
      os.tmpdir(),
      `modalities-remote-${Date.now()}.d.ts`,
    );
    await fs.writeFile(tmpRemotePath, remoteTypesSource);
    const program = ts.createProgram([filePath, tmpRemotePath], {});
    const checker = program.getTypeChecker();

    // Get local and remote type symbols
    const localSourceFile = program.getSourceFile(filePath);
    const remoteSourceFile = program.getSourceFile(tmpRemotePath);
    if (!localSourceFile || !remoteSourceFile) {
      console.error("Could not load source files for type checking.");
      process.exit(1);
    }

    // Map type names to symbols
    const getTypeSymbols = (sourceFile: ts.SourceFile) => {
      const symbols: Record<string, ts.Symbol> = {};
      sourceFile.forEachChild((node) => {
        if (
          ts.isInterfaceDeclaration(node) ||
          ts.isTypeAliasDeclaration(node)
        ) {
          const name = node.name.text;
          const symbol = checker.getSymbolAtLocation(node.name);
          if (symbol) symbols[name] = symbol;
        }
      });
      return symbols;
    };
    const localSymbols = getTypeSymbols(localSourceFile);
    const remoteSymbols = getTypeSymbols(remoteSourceFile);

    // Check assignability
    let errors: string[] = [];
    for (const typeName in localSymbols) {
      if (!remoteSymbols[typeName]) {
        errors.push(
          `Type/interface '${typeName}' does not correspond to any model on the server.`,
        );
        continue;
      }
      const localType = checker.getDeclaredTypeOfSymbol(localSymbols[typeName]);
      const remoteType = checker.getDeclaredTypeOfSymbol(
        remoteSymbols[typeName],
      );
      if (!checker.isTypeAssignableTo(remoteType, localType)) {
        errors.push(
          `NLX modality type for '${typeName}' is not assignable to local type.

${chalk.bold("NLX modality type definition:")}

${remoteSymbols[typeName].declarations?.[0]?.getText() ?? checker.typeToString(remoteType)}

${chalk.bold("Local type definition:")}

${localSymbols[typeName].declarations?.[0]?.getText() ?? checker.typeToString(localType)}
          `,
        );
      }
    }

    await fs.unlink(tmpRemotePath);

    if (errors.length) {
      let errorMsg = "Type check failed:\n";
      for (const err of errors) errorMsg += `  - ${err}\n`;
      console.error(errorMsg.trim());
      process.exit(1);
    } else {
      console.log(
        "Type check passed: all remote types are assignable to local types.",
      );
      process.exit(0);
    }
  });
